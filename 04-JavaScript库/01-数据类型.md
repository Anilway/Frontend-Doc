# 数据类型

> 基本数据类型：数字(Number)、字符串(String)、布尔(Boolean)、对空(Null)、未定义(Undefined)、Symbol(表示独一无二的值)
>
> 引用数据类型：对象(Object)、数组(Array)、函数(Function)

- 基本类型特点：

  - 内容直接存储在栈中（大小固定位置连续的存储空间）
  - 录的是该数据类型的值，即直接访问
  - 保存与复制的是值本身
  - 方法中定义的变量都是放在栈内存中
  - 使用 typeof 检测数据的类型 ref 类型判断

- 引用类型特点：

  - 占用空间不固定，保存在堆中这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用
  - 保存与复制的是指向对象的一个指针
  - 使用 instanceof 检测数据类型 ref 类型判断
  - 使用 new()方法构造出的对象是引用型 ref new

## 常用操作

- number 数字

  - 整型

    - 如：1，-1
    - 如何判断 —— Number.isInteger(1) // true
    - 如何转整型
      - parseInt('1') // 1
      - parseInt('1.9') // 1
    - 真假倾向：只有 0 为 false 其他均为 true

  - 浮点型

    - 如：0.1，1.1，.1 如果小于 1，小数点前的 0 可以省略
    - 如何转浮点型
      - parseFloat('1') // 1
      - parseFloat('1.1') // 1.1

  - 非数：NaN

    - 一般在出错或不可预料的结果中出现，如：'a' / 'b'，0 / 0
    - NaN == NaN 或 NaN === NaN // false
    - 判断是否为 NaN 可以使用 isNaN()函数
      - isNaN(0 / 0) // true
      - isNaN(1) // false

  - 无穷：(±)Infinity

- string 字符串

  - 引号：选用单引
  - 转义符：\
  - 反引号：`我是个模板字符串，我叫 ${name}` 使用`（反引号）定义模板字符串，原样输出，可以传入变量，还可以直接断行
  - 常用方法

    - 获得字符串中的某一个字符

      ```
      'yo'.charAt(0); // "y" 程序员是从0开始数的
      'yo'.charAt(1); // "o"
      'yo'[0]; // "y"
      ```

    - 检查一段字符是否包含另一段字符

      ```
      '花花你好'.includes('花花'); // true
      '花花你好'.includes('拴蛋'); // false
      ```

    - 用字符串将字符串分割为数组

      ```
      '花花→_→拴蛋→_→背背'.split('→_→'); // ["花花", "拴蛋", "背背"]
      ```

    - 连接字符串

      ```
      'y'.concat('ooo', 'oo', 'o'); // "yoooooo"，依次连接传入的字符，传参数量不限
      ```

    - 切片字符串

      ```
      var str = '王花花和小熊跳舞跳呀跳呀一二一';
      str.slice(3, 8); // "和小熊跳舞"，第一个传参为开始索引，第二个传参为结束索引(但不包括)
      str.slice(3); // "和小熊跳舞跳呀跳呀一二一"，若省略第二个传参将会截取至最后一个字符
      ```

    - .trim 移除两头的空格

      ```
      '  yo  '.trim(); // "yo"
      '  yo'.trim(); // "yo"
      ```

- boolean 布尔值

  - true
  - false

- null 空

  - 使用
    - null 只有在需要明确指定（或清空）一个量时才使用，如删除用户介绍：user.intro = null
    - null 只能手动设置，JS 本身不会将任何量的默认值设为 null
  - 注意
    - typeof null 会返回 "object"。这是开发者的锅，莫得办法！

- undefined 未定义

  - 注意
    - undefined == null //true
    - undefined === null //false

- object 对象 —— 属性和方法

  - 为什么会有这种类型？因为好组织

    ```
    // 第一种写法
    var 人名 = '王花花';
    var 狗的年龄 = 3;
    var 人的年龄 = 20;
    var 狗的职业 = '保卫员';
    var 人的部门 = '序员鼓励部';
    var 狗名 = '李拴蛋';
    var 人的职业 = '序员鼓励师';
    var 狗的部门 = '序员保卫处';

    // 第二种写法
    var 花花 = {
      姓名: '王花花',
      年龄: 20,
      职业: '序员鼓励师',
      部门: '序员鼓励部',
    };
    var 拴蛋 = {
      姓名: '李拴蛋',
      年龄: 3,
      职业: '保卫员',
      部门: '序员保卫处',
    };
    ```

  - 对象中还可以嵌套对象

    ```
    var 花花 = {
      姓名: '王花花',
      年龄: 20,
      职业: '序员鼓励师',
      部门: '序员鼓励部',
      服务于: {
        姓名: '程续缘',
        技术: 'PHP'
      }
    };
    ```

  - key 和 value，键名一般使用英文和数字，其实使用任何字符都可以，只不过当键名中有空格和特殊字符时外部需要加引号包住

    ```
    {
      'yo yo yo': 'Mu Ha Ha'
    };
    ```

  - 获取对象中的属性

    1.可以使用.来获取属性

    ```
    var obj = {
      a: 1
    };

    obj.a // 1

    // 嵌套对象也没问题
    var obj = {
      a: 1,
      b: 2,
      c: {
        c1: 666
      }
    };

    obj.c.c1 // 666
    ```

    2.可以使用 object['key'] 来获取属性

    ```
    var obj = {
      'a b C': 'mmp'
    };

    obj['a b C'] // 'mmp'

    // 嵌套对象也没问题
    var obj = {
      a: 1,
      b: 2,
      c: {
        c1: 666
      }
    };

    obj['c']['c1'] // 666
    ```

  - 对象中的数据类型有限制吗？没有，以下的键值都是合法的

    ```
    var obj = {
      a: [1], // 数组
      b: {}, // 对象
      c: 1, // 数字
      d: true, // 布尔值
      e: 'yo', // 字符串
    }
    ```

  - 声明之后还可以加新键吗？可以

    ```
    var obj = {};
    obj.a = 1;
    console.log(obj) // {a: 1}
    ```

  - 键名可以重复吗？不可以，后一个会覆盖前一个

- array 数组

  - 为什么会有这种类型？因为好组织

    ```
    var 同学1 = '王花花';
    var 科目1 = '传呼机打蜡指南';
    var 同学2 = '李拴蛋';
    var 科目2 = '上网冲浪必修';
    var 同学3 = '刘备备';
    var 科目3 = '网络词汇必修';

    var 同学 = [
      '王花花',
      '李拴蛋',
      '刘备备'
    ];

    var 科目 = [
      '传呼机打蜡指南',
      '上网冲浪必修',
      '网络词汇必修'
    ];
    ```

  - 元素类型不限

    ```
    [
      2,
      true,
      'a',
      {},
      function() {}
    ]
    ```

  - 获取元素

    ```
    var 各种排排坐 = [['a1', 'a2'], ['b1', 'b2'], ['c1', ['c2']]];
    各种排排坐[0][0] // 'a1'
    各种排排坐[1][0] // 'b1'
    各种排排坐[2][0] // 'c1'
    ```

  - 通过.length 获取数组的长度（里面有几个元素）

    ```
    [5, 10, 15].length // 3
    ```

  - 常用方法

    - .unshift(新元素) 从开头添加

      ```
      var arr = [3, 4, 5];
      arr.unshift(2); // 4 返回修改后的长度
      console.log(arr); // [2, 3, 4, 5]
      ```

    - .push(新元素) 从末尾添加

      ```
      var arr = [3, 4, 5];
      arr.push(6); // 4 返回修改后的长度
      console.log(arr); // [3, 4, 5, 6]
      ```

    - .shift() 从开头删

      ```
      var arr = [2, 3, 4, 5];
      arr.shift(); // 2 返回被删除的数
      console.log(arr); // [3, 4, 5]
      ```

    - .pop() 从末尾删

      ```
      var arr = [3, 4, 5, 6];
      arr.pop(); // 6 返回被删除的数
      console.log(arr); // [3, 4, 5]
      ```

    - .reverse() 颠倒顺序

      ```
      [1, 2, 3].reverse(); // [3, 2, 1]
      ```

    - .splice(从哪剪, 剪多长, 替换元素 1, 替换元素 2); 剪接，影响原数组

      ```
      var 片儿 = ['a', 'b', '辣鸡1', '辣鸡2', 'c'];
      // 从第3格开始剪，剪2格
      片儿.splice(2, 2); // ["辣鸡1", "辣鸡2"] 返回减掉的东西
      console.log(片儿); // ["a", "b", "c"]

      // 注意，现在片儿已经剪成了['a', 'b', 'c']
      // 从第2格开始剪，剪1格，进两个广告
      片儿.splice(1, 1, '广告1', '广告2');
      console.log(片儿); // ["a", "广告1", "广告2", "c"]
      ```

    - .slice(从哪剪，在哪停); 剪裁，返回剪裁的新数组，不影响原数组

      ```
      var 片儿 = ['a', 'b', '辣鸡1', '辣鸡2', 'c'];
      // 从第3格开始剪，剪2格
      var 垃圾堆 = 片儿.slice(2, 4); // ["辣鸡1", "辣鸡2"] 返回减掉的东西
      console.log(垃圾堆); // ["辣鸡1", "辣鸡2"]
      ```

    - .forEach(回调函数); 迭代

      ```
      ['a', 'b', 'c'].forEach(function(每一条, 索引) {
        console.log('第' + 索引 + '条：' + 每一条);
      });

      // 第0条：a
      // 第1条：b
      // 第2条：c
      ```

    - .filter(回调函数); 过滤器，通过你给他的条件返回一个新数组

      ```
      var 旧数组 = [1, 2, 3, 4];
      var 新数组 = 旧数组.filter(
        // 传入一个函数，每迭代一个元素就执行一次
        function(元素, 索引, 原始数组) {
          // 只要大于2的元素
          var 条件 = 元素 > 2;
          return 条件;
        }
      );

      console.log(新数组); // [3, 4]
      ```

    - .every(回调函数); 每一条，每一条都满足你给的条件

      ```
      var 满足 = [1, 2, 3].every(
        // 传入一个函数，每迭代一个元素就执行一次
        function(元素, 索引, 原始数组) {
          // 是否小于10
          var 条件 = 元素 < 10;
          return 条件;
        }
      );
      /*只有当所有条件都满足时才返回true*/
      console.log(满足); // true
      ```
