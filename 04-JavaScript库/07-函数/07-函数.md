# 函数

> 作用：一次封装，四处调用

- 命名函数
- 匿名函数

## 1、JS 函数介绍

- 函数**可以被调用、可以作为参数、可以作为返回值**
- **函数本质也是一种对象**
- 每个函数都有一个（显式属性）`prototype`属性与（隐式原型）`__proto__`属性

## 2、函数定义和函数位置

### 2.1 函数定义

- function 直接定义

  ```js
  // function直接定义，会函数声明提升
  function add(argument) {
    // ...
  }
  ```

- 函数表达式

  ```js
  // 函数表达式，不会函数声明提升
  var add = function(argument) {
    // ...
  };
  ```

- 构造函数

  ```js
  var add = new Function("num1", "num2", "return num1 + num2");
  ```

> 总结：尽量选用 function 直接定义，若选择函数表达式请注意它不会函数声明提升，构造函数太复杂不建议

### 2.2 函数位置

- 全局作用域：哪里都可以，直接调用
- 局部作用域：理解作用域链（详见 08-作用域章节）
- if/for 等代码块：JS 没有块级作用域，所以**最好不要在 if/for 等代码块中定义函数**
- 对象中：作为对象的方法，`对象.函数名()；`来调用

## 3、函数的调用

### 3.1 直接调用

- 一般调用：`函数名();`
- 针对**匿名函数**，本质就是不要 function 开头：`(函数体)();`或`(函数体());`或`!函数体()`
- 递归调用：自己调用自己

  ```js
  // 计算阶层函数：num!
  function factorial(num) {
    if (num <= 1) {
      return 1;
    }
    return num * factorial(num - 1);
  }

  console.log(factorial(5)); // 计算5!，结果：124
  ```

- 对象中的方法调用

  - "."或"[ ]"：`对象.方法名();`或`对象["方法名"]();`
  - 链式调用（**慎用**）：`A.B.C.D();` ABCD 可以是同一级（此时必须写`return this;`），也可以是嵌套关系

- 构造函数的调用：`new 函数名();`

### 3.2 间接调用

- call 和 apply

> 本质是改变 this 的指向，区别是传参形式不同而已（详见 09-this 章节）

```js
var age = 10;
var person = {
  age: 90,
  getAge: function(num1, num2) {
    return this.age + num1 + num2;
  }
};

console.log(person.getAge(1, 2)); // 结果：93
console.log(person.getAge.call(window, 1, 2)); // 结果：13
console.log(person.getAge.apply(window, [1, 2])); // 结果：13
```

## 4、函数的参数

> 传入的参数：可以是任意数据类型

### 4.1 实参与形参

> 本质：`形参 = 实参;`
>
> - 实参若是值类型：浅拷贝（形参改变，实参不变）
> - 实参若是引用类型：深拷贝（形参改变，实参也会变）

### 4.2 参数个数

- 实参 == 形参
- 实参 < 形参，多余形参是 undefined，应用：可选参数，为其设置默认参数（注意可选参数要在最后）
- 实参 > 形参，应用：arguments 伪数组

> 注意：`函数名.length` 指形参的个数；`arguments.length` 指实参的个数

### 4.3 arguments 伪数组专讲

- arguments 只在函数内部起作用；浅拷贝实参；与形参的指向相同（深拷贝，若重新给 arguments 赋值，形参会改变，但实参不会）；每个函数都有一个 arguments，且互不相同

  ```js
  // 实际上arguments最常用于判断传入参数的个数
  function inner() {
    console.log(arguments.length);
  }
  inner(10, 20); // 结果：2

  // 应用：求任意一组数的平均值
  function grtAvg() {
    for (var i = 0, sum = 0; i < arguments.length; i++) {
      sum += arguments[i];
    }
    avg = sum / arguments.length;
    console.log(avg);
  }
  grtAvg(10, 20, 30);
  ```

- `arguments.callee` 指代函数本身，应用：在递归函数中，若函数名发生改变时，递归也自动更新（**严格模式下失效**）

  ```js
  // 计算阶层函数：num!
  function factorial(num) {
    if (num <= 1) {
      return 1;
    }
    return num * arguments.callee(num - 1);
  }

  console.log(factorial(5)); // 计算5!，结果：124
  ```

### 4.4 传参技巧

> 当传参个数不确定时，传对象

```js
function setPerson(obj) {
  var person = {};
  person.name = obj.name || "小明";
  person.age = obj.age || 20;
  person.sex = obj.sex || "male";
  person.addr = obj.addr || "中国";
}

setPerson({
  name: "小花",
  age: 40,
  addr: "美国"
});
```

### 5、函数的返回值

- return 表示结束，默认返回 undefined
- 可以返回任意数据类型

### ES6 标准引入了 rest 参数

rest 参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定 a、b，多余的参数以数组形式交给变量 rest，所以，不再需要 arguments 我们就获取了全部参数。如果传入的参数连正常定义的参数都没填满，也不要紧，rest 参数会接收一个空数组

```js
function foo(a, b, ...rest) {
  console.log(a);
  console.log(b);
  console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// 1
// 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// 1
// undefined
// Array []
```
